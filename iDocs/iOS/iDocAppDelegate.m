////  iDocAppDelegate.m//  iDoc////  Created by Dmitry Likhachev on 11/29/09.//  Copyright KORUS Consulting 2009. All rights reserved.//#import "iDocAppDelegate.h"#import "Constants.h"#import "iPadDashboardViewController.h"#import "iPadBaseLayoutView.h"#import "SystemDataEntity.h"#import "ClientSettingsDataEntity.h"#import "ORDSyncManager.h"#import "WebDavSyncManager.h"#import "UIViewController+Alert.h"#import "UserDefaults.h"#import "SupportFunctions.h"@interface iDocAppDelegate (PrivateMethods)- (void)processSync;- (void)syncSkipped;- (void)syncCleanup;- (void)restartSync;- (void)restartSyncFromLastStep;- (BOOL)updateUserDefaultSettingsWithDefaultValues;- (void)initUserInfo;- (BOOL)isAppParam:(NSString *)appParamName isEqualToSettingsParam:(NSString *)settingsParamName;- (BOOL)isORDServerURLChanged;- (BOOL)isORDUserChanged;- (BOOL)isORDRepositoryChanged;- (BOOL)isWebDavServerURLChanged;- (BOOL)isWebDavUserChanged;- (void)ORDDataClean;- (void)webDavDataClean;- (void)checkNetworkStatus:(NSNotification *)notice;- (void)setNetworkStatus:(NetworkStatus)status;- (NSString *)PCSyncLockFilePath;- (BOOL)lockDocuments:(BOOL)lock;- (BOOL)incompletePCSync;- (void)showIncompletePCSyncWarning;@end@implementation iDocAppDelegate@synthesize window;@synthesize navigationController;@synthesize syncController;@synthesize serverReachable;@synthesize serverActive;#pragma mark application management methods- (void)applicationDidFinishLaunching:(UIApplication *)application {    NSLog(@"iDocAppDelegate applicationDidFinishLaunching");        application.applicationSupportsShakeToEdit = NO;	    [[NSNotificationCenter defaultCenter] addObserver:self                                              selector:@selector(onApplicationDidBecomeActive:)                                                  name:UIApplicationDidBecomeActiveNotification                                                object:nil];        //update default settings    firstLaunch = ![self updateUserDefaultSettingsWithDefaultValues];	runSync = [UserDefaults boolSettingByKey:constSyncOnStartup];        //rerun sync if application was terminated during sync    if ([UserDefaults intSettingByKey:constSyncStatus] != SyncStatusNone) {        [SyncController setStatus:SyncStatusNone];        runSync = YES;    }	//init forms    UIWindow *appWindow = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];	self.window = appWindow;    [appWindow release];	window.userInteractionEnabled = YES;	    iPadDashboardViewController *dashboardController = [[iPadDashboardViewController alloc] init];    UINavigationController *navController = [[UINavigationController alloc] initWithRootViewController:dashboardController];	self.navigationController = navController;    [navController release];	navigationController.delegate = self;	self.window.rootViewController = navigationController; //will lock top view controller's view	[dashboardController release];        //check for internet connection - check if a pathway to a random host exists      self.serverReachable = [Reachability reachabilityForInternetConnection];    [self checkNetworkStatus];    [[NSNotificationCenter defaultCenter] addObserver:self                                              selector:@selector(checkNetworkStatus:)                                                  name:kReachabilityChangedNotification                                                object:nil];    [serverReachable startNotifier];    	[self.window addSubview:[navigationController view]];	    [self.window makeKeyAndVisible];}- (void)applicationWillTerminate:(UIApplication *)application {    NSLog(@"iDocAppDelegate applicationWillTerminate");    [[CoreDataProxy sharedProxy] saveWorkingContext];    [CoreDataProxy resetSharedProxy];	[self lockDocuments:NO];}- (void)applicationDidEnterBackground:(UIApplication *)application {    NSLog(@"iDocAppDelegate applicationDidEnterBackground. Available time: %f", ([UIApplication sharedApplication]).backgroundTimeRemaining);        if ([SyncController status] == SyncStatusIsRunningSync) {                 UIBackgroundTaskIdentifier bgTask = 0;        bgTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^ {             NSLog(@"iDocAppDelegate applicationDidEnterBackground ExpirationHandler");            [[UIApplication sharedApplication] endBackgroundTask:bgTask];        }];        [self.syncController abortSync];        [SyncController setStatus:SyncStatusAbortedInBackground];        [SyncController saveSuspendDate];        [[UIApplication sharedApplication] endBackgroundTask:bgTask];    }    else {        [self lockDocuments:NO];            } }- (void)applicationWillEnterForeground:(UIApplication *)application	{    NSLog(@"iDocAppDelegate applicationWillEnterForeground");}- (void)onApplicationDidBecomeActive:(NSNotification *)notification {    NSLog(@"iDocAppDelegate onApplicationDidBecomeActive");	if ([self incompletePCSync]) {		NSLog(@"iDocAppDelegate ERROR: iDocSync synchronization was not completed!");		[self showIncompletePCSyncWarning];	}	    else {        if (incompletePCSyncWarning) {            [incompletePCSyncWarning dismissWithClickedButtonIndex:1 animated:YES];        }                [self lockDocuments:YES];                if (firstLaunch == YES) {            firstLaunch = NO;            if ([navigationController.topViewController isMemberOfClass:[iPadDashboardViewController class]]) {                [(iPadDashboardViewController *)navigationController.topViewController settingsButtonPressed];            }        }        else {            SyncStatus status = [SyncController status];            NSLog(@"Sync status: %i", status);            switch (status) {                case SyncStatusNone:                    [CoreDataProxy initSharedProxy];                    [self checkSyncRequired];                    break;                case SyncStatusAbortedInBackground:                    NSLog(@"SyncStatus:SyncStatusAbortedInBackground");                    [self.syncController showWaitForSyncResetFinishVeil];                    break;                default:                    [SyncController setStatus:SyncStatusNone];                    [self performSelectorOnMainThread:@selector(restartSync) withObject:nil waitUntilDone:NO];                     break;            }        }    }}- (void)restartSyncFromLastStep {    NSLog(@"iDocAppDelegate restartSyncFromLastStep");    runSync = YES;    [self checkSyncRequired];}- (void)restartSync {    NSLog(@"iDocAppDelegate restartSync");    [SyncController resetLastCompletedStep];    [CoreDataProxy resetSharedProxy];    [CoreDataProxy restoreDB];    [CoreDataProxy initSharedProxy];    [self initUserInfo];    runSync = YES;    [self checkSyncRequired];}#pragma mark sync methods- (void)checkSyncRequired {    NSLog(@"iDocAppDelegate checkSyncRequired");    [[NSUserDefaults standardUserDefaults] synchronize];    BOOL ORDServerURLChanged, ORDUserChanged, ORDRepositoryChanged, webDavServerURLChanged, webDavUserChanged;    BOOL updateUser = NO;        // ORD server    if ([UserDefaults useTestData] == YES) {        NSLog(@"iDocAppDelegate using ORD test data");        ORDServerURLChanged = ORDUserChanged = ORDRepositoryChanged = YES;        [UserDefaults saveValue:nil forSetting:constLastLoggedInORDUser];        [UserDefaults saveValue:constEmptyStringValue forSetting:constDictionariesLastUpdatedDate];    }    else {        NSLog(@"iDocAppDelegate using ORD server data");        ORDServerURLChanged = [self isORDServerURLChanged];        ORDUserChanged = [self isORDUserChanged];        ORDRepositoryChanged = [self isORDRepositoryChanged];    }        if (ORDServerURLChanged == YES || ORDUserChanged == YES || ORDRepositoryChanged == YES) {        [self ORDDataClean];        updateUser = YES;        runSync = YES;    }        // WebDav server    webDavServerURLChanged = [self isWebDavServerURLChanged];    webDavUserChanged = [self isWebDavUserChanged];    if (webDavServerURLChanged == YES || webDavUserChanged == YES) {        [self webDavDataClean];        updateUser = YES;        runSync = YES;    }        // general    if (updateUser == YES) {        [self initUserInfo];    }    if (runSync == YES) {        if (([UserDefaults useORDServer] == YES || [UserDefaults useTestData] == YES) || [UserDefaults useWebDavServer] == YES) {                        [CoreDataProxy backupDB];            [self performSelectorInBackground:@selector(passThroughApplicationRunLoop) withObject:nil];         }        runSync = NO;    }    else {        [self performSelectorOnMainThread:@selector(syncSkipped) withObject:nil waitUntilDone:NO];    }}- (void)passThroughApplicationRunLoop {	//to break down view rendering cycle swapping threads:	[self performSelectorOnMainThread:@selector(processSync) withObject:nil waitUntilDone:NO]; }- (void)processSync {    NSLog(@"iDocAppDelegate processSync");    //check local data    ClientSettingsDataEntity *settingsEntity = [[ClientSettingsDataEntity alloc] initWithContext:[[CoreDataProxy sharedProxy] workContext]];    BOOL hasLocalData = ([[settingsEntity selectAllDashboardItems] count] > 0) ? YES : NO;    [settingsEntity release];        //онлайн работа - запуск синхронизации с автологином    if (self.serverActive == YES || [UserDefaults useTestData] == YES) {        [self startFullSync];    }    //есть локальные данные и работаем без сервера либо сервер недоступен - добавляем информацию о пользователе без  токена и выводим    else if (self.serverActive == NO && hasLocalData == YES) {        [self syncSkipped];    }    //нет локальных данных и работаем без сервера либо сервер недоступен - показываем алерт    else if (self.serverActive == NO &&  hasLocalData == NO) {        NSString *message = NSLocalizedString(@"SyncRequiredButNoORDServerAvailableMessage", nil);        NSString *title = NSLocalizedString(@"WSErrorAlertTitle", nil);        [navigationController.topViewController showAlertWithMessage:message andTitle:title];    }}- (void)startFullSync {	NSLog(@"iDocAppDelegate startSync");    if([navigationController.topViewController isKindOfClass:iPadDashboardViewController.class]) {		iPadDashboardLayoutView *dashboardView =             (iPadDashboardLayoutView *)((iPadDashboardViewController *)navigationController.topViewController).view;        dashboardView.userNameLabel.text = constEmptyStringValue;	}	    [self startSyncWithModule:DSModuleClientSettings];}- (void)startSyncWithModule:(int)syncModule {	NSLog(@"iDocAppDelegate startSyncWithModule:%i", syncModule);      [self enableSyncOption:NO];        iPadBaseLayoutView *container = (iPadBaseLayoutView *)navigationController.topViewController.view;    UIView *syncControllerPlaceholder = container;    if (self.syncController == nil) {        iPadSyncViewController *controller = [[iPadSyncViewController alloc] initWithPlaceholder:syncControllerPlaceholder andSyncDelegate:self];        self.syncController = controller;        [controller release];    }    else {        [syncController setPlaceholder:syncControllerPlaceholder];    }        [syncController launchSyncWithModule:syncModule]; }- (void)syncFinishedForModule:(DataSyncModule)syncModule {	NSLog(@"iDocAppDelegate syncFinishedForModule:%i", syncModule);    [self enableSyncOption:self.serverActive];        if (syncModule != DSModuleActionsOnly && syncModule != DSModuleTaskAsRead && [navigationController.topViewController conformsToProtocol:@protocol(iPadSyncDelegate)]) {        [navigationController.topViewController performSelector:@selector(syncFinished)];    }    [SyncController setStatus:SyncStatusNone];}- (void)syncAbortedInBackground {	NSLog(@"iDocAppDelegate syncAbortedInBackground");     [SyncController setStatus:SyncStatusNone];    if ([SyncController isSuspendExpired] == YES) {        [self restartSync];     }    else {        [self restartSyncFromLastStep];     }}- (void)syncSkipped {	NSLog(@"iDocAppDelegate syncSkipped");	[self syncFinishedForModule:DSModuleUnknown];	}#pragma mark submit actions methods- (void)submitActionsToServer {    NSLog(@"iDocAppDelegate submitActionsToServer");    if ([UserDefaults useORDServer] == YES && self.serverActive == YES) {        [self startSyncWithModule:DSModuleActionsOnly];    }}- (void)submitTaskAsReadToServer {    NSLog(@"iDocAppDelegate submitTaskAsReadToServer");    if ([UserDefaults useORDServer] == YES && self.serverActive == YES) {        [self startSyncWithModule:DSModuleTaskAsRead];    }}#pragma mark settings methods- (BOOL)updateUserDefaultSettingsWithDefaultValues {    NSLog(@"iDocAppDelegate updateUserDefaultSettingsWithDefaultValues");    [NSUserDefaults resetStandardUserDefaults];    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];        NSString *bundlePath = [[NSBundle mainBundle] bundlePath];    NSString *settingsPath = [bundlePath stringByAppendingPathComponent:@"InAppSettings.bundle"];    NSString *plistFile = [settingsPath stringByAppendingPathComponent:@"Root.inApp.plist"];    NSDictionary *settingsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFile];    NSArray *inAppPrefsArray = [settingsDictionary objectForKey:@"PreferenceSpecifiers"];        settingsPath = [bundlePath stringByAppendingPathComponent:@"Settings.bundle"];    plistFile = [settingsPath stringByAppendingPathComponent:@"Root.plist"];    settingsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFile];    NSArray *settingsArray = [settingsDictionary objectForKey:@"PreferenceSpecifiers"];        //update app version    for(NSDictionary *item in inAppPrefsArray) {        NSString *key = [item objectForKey:@"Key"];        id defaultValue = [item objectForKey:@"DefaultValue"];        if ([key isEqualToString:constAppVersion]) {            if(![defaultValue isEqualToString:[defaults stringForKey:constAppVersion]]) {                [defaults setObject:defaultValue forKey:constAppVersion];                 [defaults synchronize];            }            break;        }    }        //update app settings if required    BOOL settingsAlreadyUpdated = [defaults boolForKey:constAppSettingsUpdated];    if (settingsAlreadyUpdated == NO) {        for(NSDictionary *item in inAppPrefsArray) {            NSString *key = [item objectForKey:@"Key"];            id defaultValue = [item objectForKey:@"DefaultValue"];                                   if ([key isEqualToString:constServerRequestTimeout]) {                if ([defaults stringForKey:constServerRequestTimeout] == nil)                     [defaults setObject:defaultValue forKey:constServerRequestTimeout];                continue;            }            else if ([key isEqualToString:constDocInfoPackageSize]) {                if ([defaults stringForKey:constDocInfoPackageSize] == nil)                     [defaults setObject:defaultValue forKey:constDocInfoPackageSize];                continue;            }            else if ([key isEqualToString:constUse3GNetwork]) {                if ([defaults stringForKey:constUse3GNetwork] == nil)                     [defaults setObject:defaultValue forKey:constUse3GNetwork];                continue;            }            else if ([key isEqualToString:constSyncDictionaries]) {                if ([defaults stringForKey:constSyncDictionaries] == nil)                     [defaults setObject:defaultValue forKey:constSyncDictionaries];                continue;            }            else if ([key isEqualToString:constSyncOnStartup]) {                if ([defaults stringForKey:constSyncOnStartup] == nil)                     [defaults setObject:defaultValue forKey:constSyncOnStartup];                continue;            }            else if ([key isEqualToString:constORDServerUrl]) {                if ([defaults stringForKey:constORDServerUrl] == nil)                     [defaults setObject:defaultValue forKey:constORDServerUrl];                continue;            }             else if ([key isEqualToString:constORDServerRepositoryName]) {                if ([defaults stringForKey:constORDServerRepositoryName] == nil)                     [defaults setObject:defaultValue forKey:constORDServerRepositoryName];                continue;            }            else if ([key isEqualToString:constORDServerUser]) {                if ([defaults stringForKey:constORDServerUser] == nil)                     [defaults setObject:defaultValue forKey:constORDServerUser];                continue;            }             else if ([key isEqualToString:constORDServerPassword]) {                if ([defaults stringForKey:constORDServerPassword] == nil)                     [defaults setObject:defaultValue forKey:constORDServerPassword];                continue;            }             else if ([key isEqualToString:constORDAttachmentDownloadType]) {                if ([defaults stringForKey:constORDAttachmentDownloadType] == nil)                     [defaults setObject:defaultValue forKey:constORDAttachmentDownloadType];                continue;            }             else if ([key isEqualToString:constErrandDueDateInterval]) {                if ([defaults stringForKey:constErrandDueDateInterval] == nil)                     [defaults setObject:defaultValue forKey:constErrandDueDateInterval];                continue;            }            else if ([key isEqualToString:constUseORDServer]) {                if ([defaults stringForKey:constUseORDServer] == nil)                     [defaults setObject:defaultValue forKey:constUseORDServer];                continue;            }            else if ([key isEqualToString:constWebDavServerUrl]) {                if ([defaults stringForKey:constWebDavServerUrl] == nil)                     [defaults setObject:defaultValue forKey:constWebDavServerUrl];                continue;            }             else if ([key isEqualToString:constWebDavServerUser]) {                if ([defaults stringForKey:constWebDavServerUser] == nil)                     [defaults setObject:defaultValue forKey:constWebDavServerUser];                continue;            }             else if ([key isEqualToString:constWebDavServerPassword]) {                if ([defaults stringForKey:constWebDavServerPassword] == nil)                     [defaults setObject:defaultValue forKey:constWebDavServerPassword];                continue;            }             else if ([key isEqualToString:constUseWebDavServer]) {                if ([defaults stringForKey:constUseWebDavServer] == nil)                     [defaults setObject:defaultValue forKey:constUseWebDavServer];                continue;            }            else if ([key isEqualToString:constCurrentTheme]) {                if ([defaults stringForKey:constCurrentTheme] == nil)                     [defaults setObject:defaultValue forKey:constCurrentTheme];                continue;            }        }                for(NSDictionary *item in settingsArray) {            NSString *key = [item objectForKey:@"Key"];            id defaultValue = [item objectForKey:@"DefaultValue"];                                   //server settings            if ([key isEqualToString:constUseTestData]) {                if ([defaults stringForKey:constUseTestData] == nil)                     [defaults setObject:defaultValue forKey:constUseTestData];                continue;	            }        }        [defaults setObject:@"YES" forKey:constAppSettingsUpdated];        [defaults synchronize];    }        return settingsAlreadyUpdated;}- (void)initUserInfo {    NSLog(@"iDocAppDelegate initUserInfo");    SystemDataEntity *systemEntity = [[SystemDataEntity alloc] initWithContext:[[CoreDataProxy sharedProxy] workContext]];    UserInfo *user = [systemEntity userInfo];    NSString *ORDLogin = [UserDefaults stringSettingByKey:constORDServerUser];    ORDLogin = (ORDLogin != nil) ? ORDLogin : constEmptyStringValue;    user.ORDLogin = ORDLogin;            NSString *ORDRepository = [UserDefaults stringSettingByKey:constORDServerRepositoryName];    ORDRepository = (ORDRepository != nil) ? ORDRepository : constEmptyStringValue;    user.ORDRepository = ORDRepository;        user.ORDToken = nil;        NSString *webDavLogin = [UserDefaults stringSettingByKey:constWebDavServerUser];    webDavLogin = (webDavLogin != nil) ? webDavLogin : constEmptyStringValue;    user.webDavLogin = webDavLogin;	    user.webDavToken = nil;        user.fio = nil;    user.position = nil;    user.organization = nil;    user.subdivision = nil;        user.ORDListSortType = nil;    user.webDavListSortType = nil;	    [[CoreDataProxy sharedProxy] saveWorkingContext];    [systemEntity release];}- (BOOL)isORDServerURLChanged {    return ![self isAppParam:constLastORDServerUrl isEqualToSettingsParam:constORDServerUrl];}- (BOOL)isORDUserChanged {    return ![self isAppParam:constLastLoggedInORDUser isEqualToSettingsParam:constORDServerUser];}- (BOOL)isORDRepositoryChanged {    return ![self isAppParam:constLastUsedORDRServerRepository isEqualToSettingsParam:constORDServerRepositoryName];}- (BOOL)isWebDavServerURLChanged {    return ![self isAppParam:constLastWebDavServerUrl isEqualToSettingsParam:constWebDavServerUrl];}- (BOOL)isWebDavUserChanged {    return ![self isAppParam:constLastLoggedInWebDavUser isEqualToSettingsParam:constWebDavServerUser];}- (BOOL)isAppThemeChanged {    return ![self isAppParam:constLastUsedTheme isEqualToSettingsParam:constCurrentTheme];}- (BOOL)isAppParam:(NSString *)appParamName isEqualToSettingsParam:(NSString *)settingsParamName {    NSLog(@"iDocAppDelegate isAppParam:%@ isEqualToSettingsParam:%@", appParamName, settingsParamName);     BOOL isEqual = YES;        NSString *appParam = [UserDefaults stringSettingByKey:appParamName];    NSString *settingsParam = [UserDefaults stringSettingByKey:settingsParamName];	settingsParam = (settingsParam == nil) ? constEmptyStringValue : settingsParam;        isEqual = (appParam != nil && [appParam isEqualToString:settingsParam]) ? YES : NO;    if (isEqual == NO) {        [UserDefaults saveValue:settingsParam forSetting:appParamName];	    }    return isEqual;   }#pragma mark data clean methods- (void)ORDDataClean {	ORDSyncManager *syncManager = [[ORDSyncManager alloc] initForCleanupWithContext:[[CoreDataProxy sharedProxy] workContext]];	[syncManager cleanupSync];	[[CoreDataProxy sharedProxy] saveWorkingContext];	[syncManager release];}- (void)webDavDataClean {    NSString *lastLoggedInWeDavUser = [UserDefaults stringSettingByKey:constLastLoggedInWebDavUser];	ClientSettingsDataEntity *settingsEntity = [[ClientSettingsDataEntity alloc] initWithContext:[[CoreDataProxy sharedProxy] workContext]];	NSArray *webDavDashboardItems = [settingsEntity selectAllWebDavDashboardItems];	for (DashboardItem *webDavDashboardItem in webDavDashboardItems) {		NSString *webDavSyncFolder = [SupportFunctions createWebDavFolderNameForDashboardItem:webDavDashboardItem.id];		if (![webDavSyncFolder isEqualToString:webDavDashboardItem.id]) {			[SupportFunctions deletePersonalWebDavFolderNameForUser:lastLoggedInWeDavUser usingDashboardItem:webDavDashboardItem.id];			break;		}	}	[settingsEntity release];	}#pragma mark internet reachability- (void)checkNetworkStatus {    NetworkStatus status = [serverReachable currentReachabilityStatus];    [self setNetworkStatus:status];    }- (void)checkNetworkStatus:(NSNotification *)notice {     [self checkNetworkStatus];}- (void)setNetworkStatus:(NetworkStatus)status {    switch (status) {        case NotReachable: {            NSLog(@"A gateway to the host server is down.");            self.serverActive = NO;            break;        }        case ReachableViaWiFi: {            NSLog(@"A gateway to the host server is working via WIFI.");            self.serverActive = YES;            break;        }        case ReachableViaWWAN: {            NSLog(@"A gateway to the host server is working via WWAN.");            self.serverActive = ([UserDefaults boolSettingByKey:constUse3GNetwork] == YES) ? YES : NO;            break;        }    }    [self enableSyncOption:self.serverActive];}- (void)enableSyncOption:(BOOL)enableSyncOption {    NSLog(@"iDocAppDelegate enableSyncOption:%@", enableSyncOption ? @"YES" : @"NO");    for (UIViewController *viewController in navigationController.viewControllers) {         if ([viewController conformsToProtocol:@protocol(NetworkReachabilityDelegate)] == YES) {            if (enableSyncOption == YES)                [viewController performSelector:@selector(enableSyncOption)];            else                [viewController performSelector:@selector(disableSyncOption)];        }     }}#pragma mark PC sync- (BOOL)lockDocuments:(BOOL)lock {	NSString *documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];	static NSString * lockFile = @"iDoc.lock";	NSString * lockFilePath = [documentsDirectory stringByAppendingPathComponent:lockFile];	NSError * err = nil;	if (lock) {		if (![[NSFileManager defaultManager] fileExistsAtPath:lockFilePath])			[@"" writeToFile:lockFilePath atomically:YES encoding:NSUTF8StringEncoding error:&err];	}	else {		if ([[NSFileManager defaultManager] fileExistsAtPath:lockFilePath])			[[NSFileManager defaultManager] removeItemAtPath:lockFilePath error:&err];					}		if (err) {		NSLog(@"iDocAppDelegate failed to %@ data: %@", (lock) ? @"lock" : @"unlock", err);		return !lock;	}		return lock;}- (NSString *)PCSyncLockFilePath {	static NSString * iDocSyncLockFile = @"iDocSync.lock";	NSString *documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];	return [documentsDirectory stringByAppendingPathComponent:iDocSyncLockFile];	}- (BOOL)incompletePCSync {	return [[NSFileManager defaultManager] fileExistsAtPath:[self PCSyncLockFilePath]];}- (void)showIncompletePCSyncWarning {	if (incompletePCSyncWarning) return;	incompletePCSyncWarning = [[UIAlertView alloc] initWithTitle:nil														  message:NSLocalizedString(@"CorruptedDataBaseWarning", nil)														 delegate:self												cancelButtonTitle:NSLocalizedString(@"CancelButtonTitle", nil)												otherButtonTitles:NSLocalizedString(@"ContinueButtonTitle", nil), nil];	[incompletePCSyncWarning show];}- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex {	if (alertView != incompletePCSyncWarning)         return;		if (buttonIndex == alertView.cancelButtonIndex) {		abort();	}		[incompletePCSyncWarning release];	incompletePCSyncWarning = nil;		if (buttonIndex != alertView.firstOtherButtonIndex) return;		// Очистить все данные синхронизации.	[self ORDDataClean];	[self webDavDataClean];    [UserDefaults saveValue:constEmptyStringValue forSetting:constLastSuccessfullSyncDate];	// Удалить lock-файл.	NSString * lockFilePath = [self PCSyncLockFilePath];	if ([[NSFileManager defaultManager] fileExistsAtPath:lockFilePath]) {		NSError * err = nil;		[[NSFileManager defaultManager] removeItemAtPath:lockFilePath error:&err];							if (err) NSLog(@"iDocAppDelegate failed %@", err);	}	// Продолжить запуск.	[self lockDocuments:YES];	    [self checkSyncRequired];}#pragma mark Memory management- (void)dealloc {    [[NSNotificationCenter defaultCenter] removeObserver:self];	    self.syncController = nil;	self.navigationController = nil;    self.serverReachable= nil;    	[window release];	[super dealloc];}@end